package com.doit.review;

public class review {
    /*
多线程:
    两种定义使用方式:
                匿名对象调用:以下两种都可以用
            直接继承Thread类
            实现Runnable接口:
                    优点:解决了java单继承的缺点
                        解耦合  第一种方式 线程任务和线程对象是耦合在一起的  第二种方式线程任务和线程对象分开 解耦合
                        多条线程共享一个任务
    基本方法;
            getname setname  curretThread(静态)
            sleep:静态方法,类名直接调用(怎么看它让哪个线程睡?) 当前线程进入睡眠
            join:在方法m1中用Thread子类对象或Runnable实现类对象(t1)调用,t1的run插队到m1之前
         ***进程中断:调用interrupt释放是否需要中断信号,isinterrupt接收后自行判定如何中断
            守护进程:
                  用户线程与守护线程
                 我们写的所有线程默认都是用户线程 JVM会保证用户线程全部执行完毕 才会退出
                 如果所有用户线程执行完毕 守护线程即使没有执行完 JVM也会退出
                 最常见的守护线程 垃圾回收器
            执行优先级: 1-10级 默认都是5,但就算设置了也不能保证它一定先执行完
    线程安全:    多条线程共同跑一个任务,而不能让其发生冲突
            线程同步(sys):
                sys(唯一锁标识){ 执行代码块 }     这里唯一标识可以是创建好的object,也可以是this(Runnable实现类对象)
                方法声明void前加上sys,相当于该方法体用sys包裹;  该方法也可以是静态的,这时唯一标识不再是this,而是类名.class
                        Runnable实现类对象--->调用重写的run方法--->方法内调用sys修饰的方法
            lock: 比sys灵活
                创建lock实现类ReentrantLock对象l,在可能会被多条线程抢占的代码上下加上l..lock 和l.unlock
                        注意:死循环下若一直lock而没有及时unlock,一会lock满了就会包error,这里不是异常!!!
    线程的wait方法:
            该方法是object类的方法,必须用线程安全的唯一标识(锁或叫监视器)去调用,必须写在线程同步(sys)执行代码块内部
            线程抢到锁(线程安全唯一标识)后才可进入代码块中执行,遇到wait后停止执行并还锁,必须用相同标识调用notify方法后,它拿到锁继续向下执行

            注意:wait和notify方法必须由对象监视器调用
                 必须在同步中使用
                 当线程遇到wait方法 进入到等待状态 注意此时线程会将锁释放
                 使用哪个对象监视器调用的wait方法 必须由这个对象监视器调用notify方法才能唤醒
                 如果对象监视器上 等待了多条线程 notify方法只是唤醒其中一个
                 如果想全部唤醒 调用notifyAll方法

            wait和sleep的区别?
                 sleep是Thread类的静态方法  既可以在同步外使用 也可以在同步内使用
                 如果在同步中使用 线程sleep的时候 并不会释放锁
                 wait是Object类的方法  只能在同步内 被锁对象调用  当线程wait时 会释放掉锁对象
                 必须有人唤醒 唤醒后需要重新获取锁后才能执行
    线程生命周期:
            new(子类对象)时出生
            调用start方法,run开始跑后:
                    锁阻塞:抢到锁执行,没抢到,等着
                    调用wait等着:
                            (1)无限等待,知道notify唤醒,进入锁阻塞状态
                            (2)计时等待:sleep(没有还锁)带参wait(还锁)
                    run方法执行结束或被stop:线程终止


     */
    public static void main(String[] args) {

    }
}
